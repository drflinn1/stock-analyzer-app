name: Alpaca — Crypto Paper (single-file)

on:
  workflow_dispatch:
    inputs:
      SYMBOL:
        description: "Trading pair (e.g., BTC/USD, SOL/USD)"
        required: true
        default: "BTC/USD"
      BUY_USD:
        description: "USD notional to buy when flat"
        required: true
        default: "25"
      TP_PCT:
        description: "Take-profit %"
        required: true
        default: "5"
      SL_PCT:
        description: "Stop-loss %"
        required: true
        default: "2"
      EARLY_DROP_PCT:
        description: "Extra stop % during first minutes with a new position"
        required: true
        default: "1"
      EARLY_WINDOW_MIN:
        description: "How long EARLY_DROP_PCT applies (minutes)"
        required: true
        default: "60"
      LIMIT_SLIP_PCT:
        description: "If >0 use LIMIT through the book; 0 = MARKET (fills fast on paper)"
        required: true
        default: "0"
      DRY_RUN:
        description: "ON to simulate; OFF to place real PAPER orders"
        required: true
        default: "OFF"   # OFF = real PAPER orders

env:
  PYTHONUNBUFFERED: "1"

jobs:
  paper_crypto:
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Set up job
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install requests

      # IMPORTANT: use the CRYPTO paper base URL secret, not the equities one
      - name: Normalize base URL (paper crypto only)
        run: |
          if [ -n "${{ secrets.ALPACA_PAPER_BASE_URL }}" ]; then
            echo "ALPACA_BASE_URL=${{ secrets.ALPACA_PAPER_BASE_URL }}" >> $GITHUB_ENV
          else
            # hard-coded safe default for paper trading
            echo "ALPACA_BASE_URL=https://paper-api.alpaca.markets/v2" >> $GITHUB_ENV
          fi

      - name: Preflight — verify Alpaca auth
        id: preflight
        env:
          AKEY: ${{ secrets.ALPACA_CRYPTO_KEY }}
          ASEC: ${{ secrets.ALPACA_CRYPTO_SECRET }}
          AURL: ${{ env.ALPACA_BASE_URL }}
        run: |
          set -euo pipefail
          python - << 'PY'
          import json, os, requests, sys, pathlib

          AKEY = os.environ["AKEY"]
          ASEC = os.environ["ASEC"]
          AURL = os.environ["AURL"]

          outdir = pathlib.Path("alpaca_state")
          outdir.mkdir(exist_ok=True)

          s = requests.Session()
          s.headers.update({
              "APCA-API-KEY-ID": AKEY,
              "APCA-API-SECRET-KEY": ASEC,
          })

          # log which URL we actually used
          print(f"[preflight] Using base URL: {AURL}", file=sys.stderr)

          r = s.get(f"{AURL}/account", timeout=20)
          r.raise_for_status()
          acct = r.json()

          ok = acct.get("status") == "ACTIVE" and (acct.get("crypto_status") in ("ACTIVE", ""))

          snap = {
              "ok": bool(ok),
              "why": "",
              "status": r.status_code,
              "account": {
                  "id": acct.get("id"),
                  "status": acct.get("status"),
                  "paper": acct.get("paper_trading", None),
                  "crypto_status": acct.get("crypto_status", ""),
                  "currency": acct.get("currency", ""),
              },
          }

          (outdir / "preflight_auth.json").write_text(json.dumps(snap, indent=2))

          if not ok:
              print("Account not ACTIVE or crypto not enabled.", file=sys.stderr)
              sys.exit(1)
          PY

      - name: Run bot and capture state (with order audit)
        env:
          AKEY: ${{ secrets.ALPACA_CRYPTO_KEY }}
          ASEC: ${{ secrets.ALPACA_CRYPTO_SECRET }}
          AURL: ${{ env.ALPACA_BASE_URL }}
          DURL: https://data.alpaca.markets/v1beta3/crypto/us
          SYMBOL: ${{ inputs.SYMBOL }}
          BUY_USD: ${{ inputs.BUY_USD }}
          TP_PCT: ${{ inputs.TP_PCT }}
          SL_PCT: ${{ inputs.SL_PCT }}
          EARLY_DROP_PCT: ${{ inputs.EARLY_DROP_PCT }}
          EARLY_WINDOW_MIN: ${{ inputs.EARLY_WINDOW_MIN }}
          LIMIT_SLIP_PCT: ${{ inputs.LIMIT_SLIP_PCT }}
          DRY_RUN: ${{ inputs.DRY_RUN }}
        run: |
          set -euo pipefail
          python - << 'PY'
          import json, os, pathlib, requests, time

          AKEY = os.environ["AKEY"]
          ASEC = os.environ["ASEC"]
          AURL = os.environ["AURL"]
          DURL = os.environ["DURL"]
          SYMBOL = os.environ["SYMBOL"].strip()
          BUY_USD = float(os.environ["BUY_USD"])
          TP_PCT = float(os.environ["TP_PCT"])
          SL_PCT = float(os.environ["SL_PCT"])
          EARLY_DROP_PCT = float(os.environ["EARLY_DROP_PCT"])
          EARLY_WINDOW_MIN = int(os.environ["EARLY_WINDOW_MIN"])
          LIMIT_SLIP_PCT = float(os.environ["LIMIT_SLIP_PCT"])
          DRY_RUN = (os.environ["DRY_RUN"].upper() == "ON")

          outdir = pathlib.Path("alpaca_state")
          outdir.mkdir(exist_ok=True)

          s = requests.Session()
          s.headers.update({
              "APCA-API-KEY-ID": AKEY,
              "APCA-API-SECRET-KEY": ASEC,
          })

          def save(name, obj):
              (outdir / name).write_text(json.dumps(obj, indent=2))

          # --- helper: latest price from data API (free for crypto) ---
          def latest_trade_price(symbol: str):
              try:
                  r = s.get(f"{DURL}/latest/trades", params={"symbols": symbol}, timeout=15)
                  r.raise_for_status()
                  js = r.json()
                  items = js.get("trades", {})
                  t = items.get(symbol) or {}
                  px = t.get("p") or t.get("price")
                  return float(px) if px is not None else None
              except Exception:
                  return None

          # Check if position exists
          r = s.get(f"{AURL}/positions", timeout=20)
          r.raise_for_status()
          positions = r.json()
          save("position_snapshot.json", positions)

          have = any(p.get("symbol") == SYMBOL for p in positions)

          last_order_detail = None

          if not have:
              # --- Build base order payload ---
              order_payload = {
                  "symbol": SYMBOL,
                  "side": "buy",
                  "time_in_force": "gtc",
              }

              px = latest_trade_price(SYMBOL)
              qty = None
              if px:
                  # Prefer qty for crypto so paper fills properly; 8 decimal places is plenty
                  qty = BUY_USD / px
                  order_payload["qty"] = f"{qty:.8f}"
              else:
                  # Fallback: no quote, use notional
                  order_payload["notional"] = str(BUY_USD)

              # --- Decide MARKET vs LIMIT ---
              if px and LIMIT_SLIP_PCT > 0:
                  # LIMIT order through the book
                  limit_price = round(px * (1 + LIMIT_SLIP_PCT / 100.0), 2)
                  order_payload.update({
                      "type": "limit",
                      "order_type": "limit",
                      "limit_price": str(limit_price),
                  })
                  note = (
                      f"Flat \u2192 LIMIT buy {SYMBOL} with ${BUY_USD} "
                      f"(qty ~{qty:.8f} at limit ~{limit_price}, src px {px}, "
                      f"slip {LIMIT_SLIP_PCT}%)."
                  )
              else:
                  # MARKET order (default when LIMIT_SLIP_PCT == 0)
                  order_payload.update({
                      "type": "market",
                      "order_type": "market",
                  })
                  if qty is not None:
                      note = (
                          f"Flat \u2192 MARKET buy {SYMBOL} with ${BUY_USD} "
                          f"(qty ~{qty:.8f}, mid px {px})."
                      )
                  else:
                      note = (
                          f"Flat \u2192 MARKET buy {SYMBOL} with ${BUY_USD} "
                          f"(no quote, using notional)."
                      )

              if DRY_RUN:
                  last_order_detail = {"id": None, "status": "simulated", **order_payload}
              else:
                  r = s.post(f"{AURL}/orders", json=order_payload, timeout=25)
                  r.raise_for_status()
                  last_order_detail = r.json()

              run_summary = {
                  "ts": int(time.time()),
                  "symbol": SYMBOL,
                  "action": "BUY",
                  "dry_run": DRY_RUN,
                  "buy_usd": BUY_USD,
                  "tp_pct": TP_PCT,
                  "sl_pct": SL_PCT,
                  "order_id": (last_order_detail or {}).get("id"),
                  "position_present": False,
                  "mid_price": px,
                  "note": note,
              }
          else:
              run_summary = {
                  "ts": int(time.time()),
                  "symbol": SYMBOL,
                  "action": "HOLD",
                  "dry_run": DRY_RUN,
                  "note": (
                      f"Position detected for {SYMBOL}; monitoring "
                      f"(TP {TP_PCT}%, SL {SL_PCT}%, early {EARLY_DROP_PCT}%/"
                      f"{EARLY_WINDOW_MIN}m)."
                  ),
              }

          save("run_summary.json", run_summary)
          save("last_order_detail.json", last_order_detail or {})

          try:
              rr = s.get(f"{AURL}/orders", params={"status": "open"}, timeout=20)
              rr.raise_for_status()
              save("orders_dump.json", rr.json())
          except Exception:
              save("orders_dump.json", {"error": "fetch_failed"})
          PY

      - name: Upload state summary (artifacts)
        uses: actions/upload-artifact@v4
        with:
          name: alpaca-paper-state
          path: |
            alpaca_state/run_summary.json
            alpaca_state/last_order_detail.json
            alpaca_state/orders_dump.json
            alpaca_state/position_snapshot.json
            alpaca_state/preflight_auth.json
