name: Crypto Live — Safe Baseline (every 5m, NEW)

on:
  workflow_dispatch:
    inputs:
      MASTER_SWITCH:
        description: "Master switch (true = allow run)"
        type: choice
        options: ["true","false"]
        default: "true"
      SIM_MODE:
        description: "Sim mode (true = DRY_RUN ON)"
        type: choice
        options: ["true","false"]
        default: "true"
      REQUIRE_RISK_ON:
        description: "Run only when risk is ON?"
        type: choice
        options: ["IGNORE","REQUIRE_ON"]
        default: "IGNORE"
  schedule:
    # keep the cron; the master switch + risk gate inside the job decide if we actually run
    - cron: "*/5 * * * *"

concurrency:
  group: crypto-live-safe
  cancel-in-progress: false

env:
  # Map inputs -> env flags your bot expects
  RUN_SWITCH: ${{ inputs.MASTER_SWITCH || 'true' }}
  DRY_RUN: ${{ (inputs.SIM_MODE || 'true') == 'true' && 'ON' || 'OFF' }}
  REQUIRE_RISK_ON: ${{ inputs.REQUIRE_RISK_ON || 'IGNORE' }}

jobs:
  live:
    name: Live Crypto Loop
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Show effective knobs
        run: |
          echo "RUN_SWITCH=${RUN_SWITCH}"
          echo "DRY_RUN=${DRY_RUN}"
          echo "REQUIRE_RISK_ON=${REQUIRE_RISK_ON}"
          echo "event_name=${GITHUB_EVENT_NAME}"

      # Optional: fast-fail if master switch is false on manual runs
      - name: Master switch gate
        shell: bash
        run: |
          if [[ "${RUN_SWITCH}" != "true" ]]; then
            echo "Master switch is OFF → exiting gracefully."
            exit 0
          fi

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps (best effort)
        shell: bash
        run: |
          set -e
          if [[ -f "requirements.txt" ]]; then
            python -m pip install --upgrade pip
            pip install -r requirements.txt
          else
            # minimal safety net; ignore failures
            python -m pip install --upgrade pip || true
            pip install pandas numpy matplotlib requests ccxt || true
          fi

      # --- Risk gate (if your repo writes .state/last_risk_signal.txt) --------
      - name: Risk gate (REQUIRE_ON)
        shell: bash
        run: |
          if [[ "${REQUIRE_RISK_ON}" == "REQUIRE_ON" ]]; then
            # If file exists and contains OFF (or missing), we skip the run
            SIG="UNKNOWN"
            if [[ -f ".state/last_risk_signal.txt" ]]; then
              SIG=$(cat .state/last_risk_signal.txt | tr -d '\r\n' | tr '[:lower:]' '[:upper:]')
            fi
            echo "Last risk signal = ${SIG}"
            if [[ "${SIG}" != "ON" ]]; then
              echo "Risk is not ON → skipping trading loop gracefully."
              exit 0
            fi
          fi

      # --- Your bot run -------------------------------------------------------
      - name: Run bot
        shell: bash
        env:
          # pass through in case your code reads these as env vars
          RUN_SWITCH: ${{ env.RUN_SWITCH }}
          DRY_RUN: ${{ env.DRY_RUN }}
          REQUIRE_RISK_ON: ${{ env.REQUIRE_RISK_ON }}
        run: |
          set -e
          echo "Starting bot… (DRY_RUN=${DRY_RUN})"
          # Adjust this line to however you normally start the crypto engine:
          # Examples:
          # python main.py --mode crypto-live
          # or
          # python trader/crypto_engine.py
          if [[ -f "main.py" ]]; then
            python main.py
          elif [[ -f "trader/crypto_engine.py" ]]; then
            python trader/crypto_engine.py
          else
            echo "No known entrypoint found; creating a placeholder .state note."
            mkdir -p .state
            echo "RUN OK $(date -u +"%Y-%m-%dT%H:%M:%SZ") DRY_RUN=${DRY_RUN}" > .state/run_summary.txt
          fi

      # Ensure filesystem writes are flushed before packaging
      - name: Flush .state to disk
        if: always()
        shell: bash
        run: |
          sync || true
          sleep 1

      # --- Visibility & artifact packaging -----------------------------------
      - name: Verify .state folder contents
        if: always()
        shell: bash
        run: |
          echo "Listing .state before archiving:"
          if [[ -d ".state" ]]; then
            ls -alh .state || true
          else
            echo "(no .state directory)"
          fi
          echo "-------------------------------------"

      - name: Create .state archive
        if: always()
        shell: bash
        run: |
          set -e
          if [[ -d ".state" ]] && [[ $(ls -A .state 2>/dev/null | wc -l) -gt 0 ]]; then
            tar -czf crypto-state_${{ github.run_id }}.tar.gz .state
            echo "Archive created:"
            ls -lh crypto-state_${{ github.run_id }}.tar.gz
          else
            echo "⚠️  .state is missing or empty — no archive will be created."
            # create a tiny note so you still see why nothing uploaded
            echo "No .state contents for run ${{ github.run_id }}" > EMPTY_STATE_NOTE.txt
          fi

      - name: Upload .state archive (if present)
        if: always() && hashFiles('crypto-state_${{ github.run_id }}.tar.gz') != ''
        uses: actions/upload-artifact@v4
        with:
          name: crypto-state_${{ github.run_id }}
          path: crypto-state_${{ github.run_id }}.tar.gz
          if-no-files-found: ignore

      - name: Upload empty-state note (if archive missing)
        if: always() && hashFiles('crypto-state_${{ github.run_id }}.tar.gz') == ''
        uses: actions/upload-artifact@v4
        with:
          name: crypto-state_${{ github.run_id }}_EMPTY
          path: EMPTY_STATE_NOTE.txt
          if-no-files-found: ignore
