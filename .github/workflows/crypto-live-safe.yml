name: Crypto Live — Safe Baseline (every 5m, NEW)

on:
  workflow_dispatch:
    inputs:
      MASTER_SWITCH:
        description: "Master switch (true = allow run)"
        type: choice
        options: ["true","false"]
        default: "true"
      SIM_MODE:
        description: "Sim mode (true = DRY_RUN ON)"
        type: choice
        options: ["true","false"]
        default: "true"
      REQUIRE_RISK_ON:
        description: "Run only when risk is ON?"
        type: choice
        options: ["IGNORE","REQUIRE_ON"]
        default: "IGNORE"
  schedule:
    - cron: "*/5 * * * *"

concurrency:
  group: crypto-live-safe
  cancel-in-progress: false

env:
  RUN_SWITCH: ${{ inputs.MASTER_SWITCH || 'true' }}
  DRY_RUN: ${{ (inputs.SIM_MODE || 'true') == 'true' && 'ON' || 'OFF' }}
  REQUIRE_RISK_ON: ${{ inputs.REQUIRE_RISK_ON || 'IGNORE' }}

jobs:
  live:
    name: Live Crypto Loop
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Show effective knobs
        run: |
          echo "RUN_SWITCH=${RUN_SWITCH}"
          echo "DRY_RUN=${DRY_RUN}"
          echo "REQUIRE_RISK_ON=${REQUIRE_RISK_ON}"
          echo "event_name=${GITHUB_EVENT_NAME}"

      - name: Master switch gate
        shell: bash
        run: |
          if [[ "${RUN_SWITCH}" != "true" ]]; then
            echo "Master switch is OFF → exiting gracefully."
            exit 0
          fi

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps (best effort)
        shell: bash
        run: |
          set -e
          if [[ -f "requirements.txt" ]]; then
            python -m pip install --upgrade pip
            pip install -r requirements.txt
          else
            python -m pip install --upgrade pip || true
            pip install pandas numpy matplotlib requests ccxt || true
          fi

      # Optional risk gate: skip real trading when signal isn't ON
      - name: Risk gate (REQUIRE_ON)
        shell: bash
        run: |
          if [[ "${REQUIRE_RISK_ON}" == "REQUIRE_ON" ]]; then
            SIG="UNKNOWN"
            if [[ -f ".state/last_risk_signal.txt" ]]; then
              SIG=$(cat .state/last_risk_signal.txt | tr -d '\r\n' | tr '[:lower:]' '[:upper:]')
            fi
            echo "Last risk signal = ${SIG}"
            if [[ "${SIG}" != "ON" ]]; then
              echo "Risk is not ON → skipping trading loop gracefully."
              exit 0
            fi
          fi

      - name: Run bot
        shell: bash
        env:
          RUN_SWITCH: ${{ env.RUN_SWITCH }}
          DRY_RUN: ${{ env.DRY_RUN }}
          REQUIRE_RISK_ON: ${{ env.REQUIRE_RISK_ON }}
        run: |
          set -e
          echo "Starting bot… (DRY_RUN=${DRY_RUN})"
          if [[ -f "main.py" ]]; then
            python main.py
          elif [[ -f "trader/crypto_engine.py" ]]; then
            python trader/crypto_engine.py
          else
            echo "No known entrypoint found; proceeding with fallback state generation."
          fi

      # ---- Ensure .state exists and has minimum files even with empty portfolio
      - name: Ensure minimal .state snapshot (even if no positions)
        if: always()
        shell: bash
        run: |
          set -e
          mkdir -p .state
          # run summary (always)
          echo "RUN_ID=${{ github.run_id }}" > .state/run_summary.txt
          echo "UTC=$(date -u +"%Y-%m-%dT%H:%M:%SZ")" >> .state/run_summary.txt
          echo "DRY_RUN=${DRY_RUN}" >> .state/run_summary.txt
          # positions.json (create if missing)
          if [[ ! -f ".state/positions.json" ]]; then
            echo '{"positions":[],"note":"empty or no open positions at time of snapshot"}' > .state/positions.json
          fi
          # kpi_history.csv (append header if missing)
          if [[ ! -f ".state/kpi_history.csv" ]]; then
            echo "ts_utc,equity,realized_pl,unrealized_pl,notes" > .state/kpi_history.csv
          fi
          # risk signal (default if missing)
          if [[ ! -f ".state/last_risk_signal.txt" ]]; then
            echo "ON" > .state/last_risk_signal.txt
          fi

      - name: Flush .state to disk
        if: always()
        shell: bash
        run: |
          sync || true
          sleep 1

      - name: Verify .state folder contents
        if: always()
        shell: bash
        run: |
          echo "Listing .state before archiving:"
          if [[ -d ".state" ]]; then
            ls -alh .state || true
          else
            echo "(no .state directory)"
          fi
          echo "-------------------------------------"

      - name: Create .state archive
        if: always()
        shell: bash
        run: |
          set -e
          if [[ -d ".state" ]] && [[ $(ls -A .state 2>/dev/null | wc -l) -gt 0 ]]; then
            tar -czf crypto-state_${{ github.run_id }}.tar.gz .state
            echo "Archive created:"
            ls -lh crypto-state_${{ github.run_id }}.tar.gz
          else
            echo "⚠️  .state is missing or empty — no archive will be created."
            echo "No .state contents for run ${{ github.run_id }}" > EMPTY_STATE_NOTE.txt
          fi

      - name: Upload .state archive (if present)
        if: always() && hashFiles('crypto-state_${{ github.run_id }}.tar.gz') != ''
        uses: actions/upload-artifact@v4
        with:
          name: crypto-state_${{ github.run_id }}
          path: crypto-state_${{ github.run_id }}.tar.gz
          if-no-files-found: ignore

      - name: Upload empty-state note (if archive missing)
        if: always() && hashFiles('crypto-state_${{ github.run_id }}.tar.gz') == ''
        uses: actions/upload-artifact@v4
        with:
          name: crypto-state_${{ github.run_id }}_EMPTY
          path: EMPTY_STATE_NOTE.txt
          if-no-files-found: ignore
