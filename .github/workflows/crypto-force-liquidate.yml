#!/usr/bin/env python3
import os, time, csv
from datetime import datetime
from typing import Dict, Tuple, Optional

import ccxt

USD_KEYS = {"USD", "ZUSD"}
STABLES = {"USDT", "USDC", "DAI"}  # will be converted to USD too

def now_ts():
    return datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S UTC")

def fnum(x) -> str:
    try:
        return f"{float(x):,.8f}".rstrip('0').rstrip('.')
    except Exception:
        return str(x)

def safe_float(x, default=0.0):
    try:
        return float(x)
    except Exception:
        return default

def pick_symbol_to_usd(markets: Dict[str, dict], base: str) -> Tuple[Optional[str], Optional[str]]:
    # prefer BASE/USD
    for candidate in (f"{base}/USD", f"{base.upper()}/USD"):
        if candidate in markets and markets[candidate].get("active"):
            return candidate, None
    # try BASE/USDT then USDT/USD
    for b in (base, base.upper()):
        s1 = f"{b}/USDT"
        if s1 in markets and markets[s1].get("active") and "USDT/USD" in markets and markets["USDT/USD"].get("active"):
            return s1, "USDT/USD"
    # try BASE/USDC then USDC/USD
    for b in (base, base.upper()):
        s1 = f"{b}/USDC"
        if s1 in markets and markets[s1].get("active") and "USDC/USD" in markets and markets["USDC/USD"].get("active"):
            return s1, "USDC/USD"
    return None, None

def main():
    dry_run = (os.getenv("DRY_RUN", "true").lower() == "true")
    api_key = os.getenv("KRAKEN_API_KEY", "")
    api_sec = os.getenv("KRAKEN_API_SECRET", "")
    api_pwd = os.getenv("KRAKEN_API_PASSWORD") or None

    print("="*80)
    print(f"[{now_ts()}] üö® FORCE LIQUIDATE START  (DRY_RUN={dry_run})")
    print("="*80)

    if not api_key or not api_sec:
        print("ERROR: Missing KRAKEN_API_KEY or KRAKEN_API_SECRET.")
        raise SystemExit(2)

    exchange = ccxt.kraken({
        "apiKey": api_key,
        "secret": api_sec,
        "password": api_pwd,
        "enableRateLimit": True,
    })

    exchange.load_markets()
    markets: Dict[str, dict] = exchange.markets

    # 0) Cancel all open orders
    try:
        print(f"[{now_ts()}] Cancelling open orders‚Ä¶")
        open_orders = exchange.fetch_open_orders()
        if open_orders:
            print(f"Found {len(open_orders)} open orders.")
            if not dry_run:
                for o in open_orders:
                    try:
                        exchange.cancel_order(o["id"], symbol=o.get("symbol"))
                        time.sleep(exchange.rateLimit/1000)
                    except Exception as e:
                        print(f"Cancel failed for {o.get('id')}: {e}")
            else:
                print("  (SIMULATION) Skipping actual cancels.")
        else:
            print("No open orders.")
    except Exception as e:
        print(f"Warn: could not fetch/cancel open orders: {e}")

    # 1) Snapshot balances ‚Üí CSV
    print(f"[{now_ts()}] Fetching balances‚Ä¶")
    bal = exchange.fetch_balance()
    total = bal.get("total", {}) or {}
    snapshot_path = f"force_liquidate_snapshot_{int(time.time())}.csv"
    with open(snapshot_path, "w", newline="") as f:
        w = csv.writer(f)
        w.writerow(["asset", "total"])
        for k, v in sorted(total.items()):
            amt = safe_float(v)
            if amt:
                w.writerow([k, amt])
    print(f"Saved pre-liquidation snapshot: {snapshot_path}")

    # 2) Build liquidation list (everything except USD/ZUSD)
    liquidation: Dict[str, float] = {}
    usd_total = 0.0
    for asset, amount in total.items():
        amt = safe_float(amount)
        if amt <= 0:
            continue
        if asset in USD_KEYS:
            usd_total += amt
            continue
        liquidation[asset] = amt

    print(f"USD/ZUSD balance: {fnum(usd_total)}")
    if not liquidation:
        print("Nothing to liquidate. Exiting cleanly.")
        return

    # Helper to normalize Kraken asset codes (e.g., XXBT ‚Üí XBT/BTC)
    def base_candidates(asset_code: str):
        u = asset_code.upper()
        cands = [u]
        if u.startswith(("X", "Z")) and len(u) > 3:
            cands.append(u[1:])
        if u.endswith(".S"):
            cands.append(u.replace(".S", ""))
        return cands

    sell_results = []
    for asset, amt in liquidation.items():
        print("-"*80)
        print(f"[{now_ts()}] Asset {asset} ‚Äî amount {fnum(amt)}")

        # Find a route to USD
        selected = None
        for cand in base_candidates(asset):
            s1, s2 = pick_symbol_to_usd(markets, cand)
            if s1:
                selected = (cand, s1, s2)
                break

        if not selected:
            print(f"!! No USD path found for {asset}. Skipping (left as-is).")
            continue

        base, first_leg, second_leg = selected

        # Check min amount using CCXT‚Äôs helpers + precision
        try:
            m1 = markets[first_leg]
            min_amt = (m1.get("limits", {}) or {}).get("amount", {}).get("min") or 0.0
            # leave tiny dust to avoid ‚Äúinsufficient funds‚Äù from fees
            use_amt = max(0.0, float(amt) * 0.999)
            if use_amt < float(min_amt):
                print(f"Too small for {first_leg}: amt={fnum(use_amt)} < min={fnum(min_amt)}. Skipping.")
                continue

            # Format via CCXT to exact step/precision
            use_amt_precise = exchange.amount_to_precision(first_leg, use_amt)

            print(f"First leg: MARKET SELL {use_amt_precise} {base} on {first_leg}")
            if not dry_run:
                order1 = exchange.create_order(first_leg, "market", "sell", float(use_amt_precise))
                print(f"  ‚Üí Order1 id {order1.get('id')}")
            else:
                print("  (SIMULATION) Not placing order.")
            time.sleep(exchange.rateLimit/1000)
        except Exception as e:
            print(f"ERROR first leg {first_leg}: {e}")
            continue

        # Second leg (if any): convert stable ‚Üí USD
        if second_leg:
            try:
                time.sleep(exchange.rateLimit/1000)
                bal2 = exchange.fetch_balance() if not dry_run else {"total": {}}
                stable_ccy = second_leg.split("/")[0]
                stable_amt = safe_float(bal2.get("total", {}).get(stable_ccy, 0))
                if stable_amt <= 0:
                    print(f"Second leg: no {stable_ccy} detected (may be pending). You can re-run later.")
                else:
                    stable_amt_use = stable_amt * 0.999
                    stable_amt_precise = exchange.amount_to_precision(second_leg, stable_amt_use)
                    print(f"Second leg: MARKET SELL {stable_amt_precise} {stable_ccy} on {second_leg}")
                    if not dry_run:
                        order2 = exchange.create_order(second_leg, "market", "sell", float(stable_amt_precise))
                        print(f"  ‚Üí Order2 id {order2.get('id')}")
                    else:
                        print("  (SIMULATION) Not placing order.")
                    time.sleep(exchange.rateLimit/1000)
            except Exception as e:
                print(f"ERROR second leg {second_leg}: {e}")

        sell_results.append((asset, amt, first_leg, second_leg or ""))

    # 4) Final USD total
    try:
        time.sleep(exchange.rateLimit/1000)
        final_bal = exchange.fetch_balance()
        final_usd = sum(safe_float(final_bal.get("total", {}).get(k, 0)) for k in USD_KEYS)
        print("-"*80)
        print(f"[{now_ts()}] ‚úÖ Done. USD-equivalents after liquidations: {fnum(final_usd)} (DRY_RUN={dry_run})")
    except Exception as e:
        print(f"Warn: could not fetch final USD: {e}")

    print("="*80)
    print("SUMMARY of attempted sells:")
    for row in sell_results:
        print(f"  - {row[0]}  amt={fnum(row[1])}  via {row[2]}  then {row[3]}")
    print("="*80)

if __name__ == "__main__":
    main()
