name: Crypto â€” Hourly 1-Coin Rotation (LIVE-ready, ultra-defensive)

on:
  schedule:
    - cron: "0 * * * *"   # Every hour at :00
  workflow_dispatch:

permissions:
  contents: write

jobs:
  rotate:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install requests pyyaml

      # ---------- Optional tiny safety net (best-effort) ----------
      - name: Seed candidates if missing (best-effort)
        run: |
          mkdir -p .state
          if [ ! -f .state/momentum_candidates.csv ]; then
            echo "pair,rank,quote" > .state/momentum_candidates.csv
            echo "EAT/USD,100,0.01" >> .state/momentum_candidates.csv
          fi

      # ---------- NEW: normalize CSV schema so rank/quote always exist ----------
      - name: Normalize candidate CSV schema
        run: |
          mkdir -p tools
          cat > tools/csv_schema_fix.py <<'PY'
#!/usr/bin/env python3
from __future__ import annotations
import csv, math
from pathlib import Path
from typing import List, Dict, Any, Optional
from trader.crypto_engine import get_public_quote, normalize_pair
STATE_DIR = Path(".state")
FILES = [STATE_DIR/"momentum_candidates.csv", STATE_DIR/"spike_candidates.csv"]
def _to_float(x):
    try:
        v=float(str(x).strip()); return v if math.isfinite(v) and v>0 else None
    except Exception: return None
def _to_int(x):
    try: return int(float(str(x).strip()))
    except Exception: return None
def _rank_from_scores(rows, score_key="score"):
    scored=[]; has=False
    for i,r in enumerate(rows):
        try: val=float(r.get(score_key)); has=True
        except Exception: val=float("-inf")
        scored.append((i,val))
    if has:
        scored.sort(key=lambda t:t[1], reverse=True)
        base=100; rank_map={_i:base-idx for idx,(_i,_) in enumerate(scored)}
        return [rank_map[i] for i in range(len(rows))]
    return [100-i for i in range(len(rows))]
def _normalize_file(path:Path)->None:
    if not path.exists(): return
    rows=[]; 
    with path.open("r", newline="", encoding="utf-8") as f:
        rd=csv.DictReader(f); hdr=[h.strip() for h in (rd.fieldnames or [])]
        for row in rd: rows.append({k.strip():v for k,v in row.items()})
    if not rows: return
    for r in rows:
        p=r.get("pair") or r.get("symbol") or r.get("PAIR") or r.get("SYMBOL") or ""
        r["pair"]=normalize_pair(str(p))
    for r in rows:
        q=_to_float(r.get("quote"))
        if q is None:
            q=_to_float(get_public_quote(r["pair"]))
        r["quote"]=f"{q:.12f}" if q is not None else ""
    have=True; ranks=[]
    for r in rows:
        rv=_to_int(r.get("rank")); ranks.append(rv); 
        if rv is None: have=False
    if not have:
        auto=_rank_from_scores(rows,"score")
        for i,r in enumerate(rows):
            r["rank"]=auto[i] if ranks[i] is None else ranks[i]
    else:
        for r in rows: r["rank"]=_to_int(r["rank"])
    core=["pair","rank","quote"]; seen=set(core); extras=[]
    for h in hdr:
        if h.lower() in ("pair","rank","quote"): continue
        if h not in seen: extras.append(h); seen.add(h)
    out_headers=core+extras
    tmp=path.with_suffix(".tmp")
    with tmp.open("w", newline="", encoding="utf-8") as f:
        wr=csv.DictWriter(f, fieldnames=out_headers); wr.writeheader()
        for r in rows:
            out={h:r.get(h,"") for h in extras}
            out["pair"]=r.get("pair",""); out["rank"]=r.get("rank",""); out["quote"]=r.get("quote","")
            wr.writerow(out)
    tmp.replace(path)
def main():
    STATE_DIR.mkdir(parents=True, exist_ok=True)
    for p in FILES:
        try: _normalize_file(p)
        except Exception as e:
            (STATE_DIR/"csv_fix_error.log").write_text(f"{p.name}: {e}\n", encoding="utf-8")
    (STATE_DIR/"last_csv_fix.txt").write_text("ok\n", encoding="utf-8")
if __name__=="__main__": main()
PY
          python tools/csv_schema_fix.py

      - name: Echo critical env/vars
        run: |
          echo "DRY_RUN=${DRY_RUN}"
          echo "BUY_USD=${BUY_USD}"
          echo "TP_PCT=${TP_PCT}"
          echo "SL_PCT=${SL_PCT}"
          echo "SLOW_GAIN_PCT=${SLOW_GAIN_PCT}"
          echo "SLOW_WINDOW_MIN=${SLOW_WINDOW_MIN}"
          echo "UNIVERSE_PICK=${UNIVERSE_PICK}"
        shell: bash

      - name: Run rotation
        env:
          # Secrets
          KRAKEN_API_KEY: ${{ secrets.KRAKEN_API_KEY }}
          KRAKEN_API_SECRET: ${{ secrets.KRAKEN_API_SECRET }}
          # Vars
          DRY_RUN: ${{ vars.DRY_RUN }}
          BUY_USD: ${{ vars.BUY_USD }}
          TP_PCT: ${{ vars.TP_PCT }}
          SL_PCT: ${{ vars.SL_PCT }}
          SLOW_GAIN_PCT: ${{ vars.SLOW_GAIN_PCT }}
          SLOW_WINDOW_MIN: ${{ vars.SLOW_WINDOW_MIN }}
          UNIVERSE_PICK: ${{ vars.UNIVERSE_PICK }}
        run: |
          python -u main.py

      - name: List .state contents
        if: always()
        run: |
          echo "----- .state -----"
          ls -la .state || true
          echo "------------------"

      # Pack and upload artifacts (always)
      - name: Zip .state
        if: always()
        run: |
          set -e
          STATE_ZIP="state-${GITHUB_RUN_NUMBER}.zip"
          if [ -d .state ] && [ "$(ls -A .state)" ]; then
            (cd . && zip -r "$STATE_ZIP" .state >/dev/null)
          else
            echo "empty" > .state/empty.txt
            (cd . && zip -r "$STATE_ZIP" .state >/dev/null)
          fi
          ls -lh "$STATE_ZIP" || true

      - name: Upload .state artifacts (zip)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: state-${{ github.run_number }}
          path: state-${{ github.run_number }}.zip
          if-no-files-found: warn
          retention-days: 7
